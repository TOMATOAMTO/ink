import React, { useEffect, useRef, useState } from 'react';
import { CANVAS_HEIGHT, CANVAS_WIDTH, KEYS } from '../constants';
import { createInitialState, updateGameState } from '../services/gameLogic';
import { drawGame } from '../services/drawing';
import { Difficulty, GameScene, GameState } from '../types';

interface GameCanvasProps {
  difficulty: Difficulty;
  onGameOver: (won: boolean) => void;
  onExit: () => void;
}

const GameCanvas: React.FC<GameCanvasProps> = ({ difficulty, onGameOver, onExit }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const requestRef = useRef<number>();
  const audioRef = useRef<HTMLAudioElement>(null); // Reference for Audio Player
  
  const gameStateRef = useRef<GameState>(createInitialState(difficulty));
  const inputKeys = useRef<Set<string>>(new Set());
  const pausedRef = useRef<boolean>(false);
  
  // Input history for double tap detection
  const lastKeyRef = useRef<string | null>(null);
  const lastKeyTimeRef = useRef<number>(0);
  
  const [hudState, setHudState] = useState<{pHp: number, pMp: number, eHp: number, eMp: number, pots: number, time: number}>({
    pHp: 1000, pMp: 100, eHp: 1000, eMp: 100, pots: 3, time: 60
  });
  const [isPaused, setIsPaused] = useState(false);

  // --- Audio Logic ---
  // Sync Audio Playback with Game Pause State
  useEffect(() => {
    if (audioRef.current) {
        if (isPaused) {
            audioRef.current.pause();
        } else {
            // Browsers allow autoplay after user interaction (clicking Start Menu counts)
            audioRef.current.play().catch(e => console.log("BGM Autoplay prevented:", e));
        }
    }
  }, [isPaused]);

  // Set initial volume
  useEffect(() => {
      if (audioRef.current) {
          audioRef.current.volume = 0.5; // 50% volume to blend with SFX
      }
  }, []);

  useEffect(() => {
    // Reset state on mount/difficulty change
    gameStateRef.current = createInitialState(difficulty);
    inputKeys.current.clear();
    pausedRef.current = false;
    setIsPaused(false);

    const handleKeyDown = (e: KeyboardEvent) => {
        if (KEYS.PAUSE.includes(e.code)) {
            pausedRef.current = !pausedRef.current;
            setIsPaused(pausedRef.current);
            return;
        }

        // Standard Input Tracking (Idempotent for Set)
        inputKeys.current.add(e.code);

        // Double Tap Dash Logic
        // Critical Fix: Ignore auto-repeat events generated by holding the key
        if (e.repeat) return;

        const now = Date.now();
        // Check for A or D
        const isLeft = KEYS.LEFT.includes(e.code);
        const isRight = KEYS.RIGHT.includes(e.code);
        
        if (isLeft || isRight) {
             const keyType = isLeft ? 'LEFT' : 'RIGHT';
             
             // Check if strict double tap (same key, short window)
             if (lastKeyRef.current === keyType && now - lastKeyTimeRef.current < 250) {
                 // Double Tap Detected!
                 const virtualKey = isLeft ? 'Virtual_DashLeft' : 'Virtual_DashRight';
                 inputKeys.current.add(virtualKey);
                 
                 // Remove it quickly so it acts as a trigger signal
                 setTimeout(() => {
                     inputKeys.current.delete(virtualKey);
                 }, 50);
                 
                 // Reset tracker to prevent chaining dashes or triple-tap confusion
                 lastKeyRef.current = null;
                 lastKeyTimeRef.current = 0;
             } else {
                 // First Tap
                 lastKeyRef.current = keyType;
                 lastKeyTimeRef.current = now;
             }
        }
    };
    const handleKeyUp = (e: KeyboardEvent) => inputKeys.current.delete(e.code);

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // --- Fixed Timestep Loop Variables ---
    let lastTime = 0;
    let accumulator = 0;
    const TIMESTEP = 1000 / 60; // 60 FPS Logic Update (approx 16.67ms)
    let frameCount = 0;

    const loop = (timestamp: number) => {
      if (pausedRef.current) {
          lastTime = timestamp; // Prevent delta spike when resuming
          requestRef.current = requestAnimationFrame(loop);
          return;
      }
      
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      // Accumulate time to process fixed logic steps
      // Cap max delta to prevent spiral of death on lag spikes
      accumulator += Math.min(deltaTime, 100); 

      const ctx = canvasRef.current?.getContext('2d');
      const state = gameStateRef.current;

      if (ctx) {
        // Update Logic in fixed steps
        while (accumulator >= TIMESTEP) {
            updateGameState(state, inputKeys.current);
            accumulator -= TIMESTEP;

            // Check End Game inside logic loop for precision
            if (state.player.state === 'DEAD' && state.player.stateTimer > 120) {
               onGameOver(false);
               return; // Stop loop
            }
            if (state.enemy.state === 'DEAD' && state.enemy.stateTimer > 180) {
               onGameOver(true);
               return;
            }
        }
        
        // Render
        if (state.cameraShake > 0) {
            ctx.save();
            const dx = (Math.random() - 0.5) * state.cameraShake * 2;
            const dy = (Math.random() - 0.5) * state.cameraShake * 2;
            ctx.translate(dx, dy);
        }
        drawGame(ctx, state);
        if (state.cameraShake > 0) ctx.restore();

        // Sync React HUD (throttle updates to ~6 times a second to save React overhead)
        frameCount++;
        if (frameCount % 10 === 0) {
            setHudState({
                pHp: state.player.hp,
                pMp: state.player.mp,
                eHp: state.enemy.hp,
                eMp: state.enemy.mp,
                pots: state.player.healPotions,
                time: Math.ceil(state.timeRemaining)
            });
        }
      }

      requestRef.current = requestAnimationFrame(loop);
    };

    requestRef.current = requestAnimationFrame(loop);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      if (requestRef.current) cancelAnimationFrame(requestRef.current);
    };
  }, [difficulty, onGameOver]);

  // Style helper for brush stroke bar
  const strokeClipPath = "polygon(0 0, 100% 2%, 98% 100%, 2% 95%)";
  const strokeClipPathRev = "polygon(0 2%, 100% 0, 98% 95%, 2% 100%)";

  return (
    <div className="relative w-[960px] h-[540px] shadow-2xl border-4 border-black bg-[#f3f0e6]">
      {/* Background Music Player */}
      <audio 
        ref={audioRef} 
        src="./bgm.mp3" 
        loop 
      />

      <canvas 
        ref={canvasRef} 
        width={CANVAS_WIDTH} 
        height={CANVAS_HEIGHT}
        className="block w-full h-full"
      />
      
      {/* Pause Menu Overlay */}
      {isPaused && (
          <div className="absolute inset-0 bg-black/60 flex flex-col items-center justify-center z-50">
              <h2 className="text-5xl text-white ink-font mb-8">暂停</h2>
              <div className="flex flex-col gap-4">
                  <button 
                    onClick={() => { pausedRef.current = false; setIsPaused(false); }}
                    className="px-8 py-2 border border-white text-white hover:bg-white hover:text-black transition-colors font-serif"
                  >
                    继续战斗
                  </button>
                  <button 
                    onClick={onExit}
                    className="px-8 py-2 border border-red-500 text-red-500 hover:bg-red-500 hover:text-white transition-colors font-serif"
                  >
                    退出游戏
                  </button>
              </div>
          </div>
      )}
      
      {/* Ink HUD Overlay - Player */}
      <div className="absolute top-4 left-4 w-72 pointer-events-none">
         <div className="flex items-end mb-1">
             <div className="text-black ink-font text-3xl mr-2 -mb-1">大侠</div>
             <div className="flex gap-1 pb-1">
                {Array.from({length: hudState.pots}).map((_, i) => (
                    <div key={i} className="w-4 h-4 bg-green-700 rounded-full border border-black shadow"></div>
                ))}
             </div>
         </div>
         {/* Player HP */}
         <div className="w-full h-6 bg-black p-1 shadow-lg" style={{ clipPath: strokeClipPath, transform: 'rotate(-1deg)' }}>
            <div className="w-full h-full bg-[#333] relative overflow-hidden">
                <div 
                    className="h-full bg-gradient-to-r from-red-900 to-red-600 transition-all duration-200" 
                    style={{ width: `${Math.max(0, (hudState.pHp / 1000) * 100)}%` }}
                ></div>
            </div>
         </div>
         {/* Player MP */}
         <div className="w-3/4 h-3 bg-black mt-1 p-0.5 shadow-lg" style={{ clipPath: strokeClipPath, transform: 'rotate(1deg)' }}>
            <div className="w-full h-full bg-[#333] relative overflow-hidden">
                <div 
                    className="h-full bg-gradient-to-r from-blue-900 to-cyan-600 transition-all duration-200" 
                    style={{ width: `${Math.max(0, hudState.pMp)}%` }}
                ></div>
            </div>
         </div>
      </div>

      {/* Ink HUD Overlay - Enemy */}
      <div className="absolute top-4 right-4 w-72 text-right pointer-events-none flex flex-col items-end">
         <div className="text-black ink-font text-3xl mb-1">{difficulty === 'GRANDMASTER' ? '武林盟主' : (difficulty === 'HARD' ? '绝世高手' : '无名之辈')}</div>
         {/* Enemy HP */}
         <div className="w-full h-6 bg-black p-1 shadow-lg" style={{ clipPath: strokeClipPathRev, transform: 'rotate(1deg)' }}>
            <div className="w-full h-full bg-[#333] relative overflow-hidden flex justify-end">
                <div 
                    className="h-full bg-gradient-to-l from-red-900 to-red-600 transition-all duration-200" 
                    style={{ width: `${Math.max(0, (hudState.eHp / 1000) * 100)}%` }}
                ></div>
            </div>
         </div>
         {/* Enemy MP */}
         <div className="w-3/4 h-3 bg-black mt-1 p-0.5 shadow-lg" style={{ clipPath: strokeClipPathRev, transform: 'rotate(-1deg)' }}>
            <div className="w-full h-full bg-[#333] relative overflow-hidden flex justify-end">
                <div 
                    className="h-full bg-gradient-to-l from-blue-900 to-cyan-600 transition-all duration-200" 
                    style={{ width: `${Math.max(0, hudState.eMp)}%` }}
                ></div>
            </div>
         </div>
      </div>

      {/* Timer - Lowered Position */}
      <div className="absolute top-6 left-1/2 -translate-x-1/2 text-5xl font-bold ink-font opacity-60 pointer-events-none select-none text-[#333]">
        {hudState.time}
      </div>
    </div>
  );
};

export default GameCanvas;